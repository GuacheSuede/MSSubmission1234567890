16
{"last_modification_time":1548363167,"language":1,"import_file":"/home/justin/MSCVProject/database/mongo-c-driver-1.13.1/src/zlib-1.2.11/contrib/puff/puff.c","args_hash":10433645398913005206,"includes":[],"dependencies":["/home/justin/MSCVProject/database/mongo-c-driver-1.13.1/src/zlib-1.2.11/contrib/puff/puff.c","/usr/include/setjmp.h","/usr/include/features.h","/usr/include/x86_64-linux-gnu/sys/cdefs.h","/usr/include/x86_64-linux-gnu/gnu/stubs.h","/usr/include/x86_64-linux-gnu/bits/setjmp.h","/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h","/usr/include/stdc-predef.h","/usr/include/x86_64-linux-gnu/bits/wordsize.h","/usr/include/x86_64-linux-gnu/gnu/stubs-64.h"],"skipped_by_preprocessor":[],"types":[],"funcs":[{"id":0,"usr":7951584339625130261,"detailed_name":"int puff(unsigned char *dest, unsigned long *destlen, const unsigned char *source, unsigned long *sourcelen)","short_name_offset":4,"short_name_size":4,"kind":12,"storage":1,"hover":"","comments":"\n Inflate source to dest.  On return, destlen and sourcelen are updated to the\n size of the uncompressed data and the size of the deflate data respectively.\n On success, the return value of puff() is zero.  If there is an error in the\n source data, i.e. it is not in the deflate format, then a negative value is\n returned.  If there is not enough input available or there is not enough\n output space, then a positive error is returned.  In that case, destlen and\n sourcelen are not updated to facilitate retrying from the beginning with the\n provision of more input data or more output space.  In the case of invalid\n inflate data (a negative error), the dest and source pointers are updated to\n facilitate the debugging of deflators.\n\n puff() also has a mode to determine the size of the uncompressed output with\n no output written.  For this dest must be (unsigned char *)0.  In this case,\n the input value of *destlen is ignored, and on return *destlen is set to the\n size of the uncompressed output.\n\n The return codes are:\n\n   2:  available inflate data did not terminate\n   1:  output space exhausted before completing inflate\n   0:  successful inflate\n  -1:  invalid block type (type == 3)\n  -2:  stored block length did not match one's complement\n  -3:  dynamic block code description: too many length or distance codes\n  -4:  dynamic block code description: code lengths codes incomplete\n  -5:  dynamic block code description: repeat lengths with no first length\n  -6:  dynamic block code description: repeat more than specified lengths\n  -7:  dynamic block code description: invalid literal/length code lengths\n  -8:  dynamic block code description: invalid distance code lengths\n  -9:  dynamic block code description: missing end-of-block code\n -10:  invalid literal/length or distance code in fixed or dynamic block\n -11:  distance is too far back in fixed or dynamic block\n\n Format notes:\n\n - Three bits are read for each block to determine the kind of block and\n   whether or not it is the last block.  Then the block is decoded and the\n   process repeated if it was not the last block.\n\n - The leftover bits in the last byte of the deflate data after the last\n   block (if it was a fixed or dynamic block) are undefined and have no\n   expected values to check.","declarations":[{"spell":"32:5-32:9|-1|1|1","param_spellings":["32:25-32:29","33:25-33:32","34:31-34:37","35:25-35:34"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]}],"vars":[{"id":0,"usr":15836500362781134965,"detailed_name":"NIL","short_name_offset":0,"short_name_size":3,"hover":"#define NIL ((unsigned char *)0)","comments":"","declarations":[],"spell":"29:11-29:14|-1|1|2","extent":"29:11-29:35|-1|1|0","uses":[],"kind":255,"storage":0}]}